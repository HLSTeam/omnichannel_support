# Story 1.4: Add monitoring and health checks

**Epic:** 1 - AI Core Infrastructure  
**Story:** 1.4  
**Status:** Draft  
**Priority:** Medium  
**Estimate:** 2 days  
**Assigned To:** TBD  

---

## Story

**As a** system administrator,  
**I want** comprehensive monitoring and health checks for the AI service,  
**so that** I can proactively identify and resolve issues before they impact users.

---

## Acceptance Criteria

1. **Real-Time Performance Monitoring**
   - Response time metrics are collected and displayed
   - Throughput (requests per minute) is tracked
   - Error rates are monitored and reported
   - Resource usage (CPU, memory) is tracked

2. **Service Health Dashboard**
   - Real-time status of all AI service components
   - Ollama service availability and performance
   - Fallback system status and usage statistics
   - Database connection and performance metrics

3. **Alerting & Notifications**
   - Configurable alert thresholds for critical metrics
   - Email/Slack notifications for service issues
   - Escalation procedures for persistent problems
   - Alert history and acknowledgment tracking

4. **Logging & Analytics**
   - Structured logging for all AI operations
   - Performance trend analysis and reporting
   - Error pattern identification and analysis
   - Usage statistics and capacity planning data

5. **Operational Tools**
   - Health check endpoints for load balancers
   - Metrics export for external monitoring systems
   - Debug endpoints for troubleshooting
   - Performance profiling tools

---

## Tasks / Subtasks

- [ ] **Task 1 (AC: 1):** Implement performance monitoring
  - [ ] Create metrics collection service
  - [ ] Add response time tracking
  - [ ] Implement throughput monitoring
  - [ ] Add resource usage tracking

- [ ] **Task 2 (AC: 2):** Build health dashboard
  - [ ] Create health status aggregator
  - [ ] Implement component health checks
  - [ ] Add real-time status updates
  - [ ] Create health dashboard API

- [ ] **Task 3 (AC: 3):** Setup alerting system
  - [ ] Configure alert thresholds
  - [ ] Implement notification channels
  - [ ] Add escalation procedures
  - [ ] Create alert management system

- [ ] **Task 4 (AC: 4):** Enhance logging and analytics
  - [ ] Implement structured logging
  - [ ] Add performance trend analysis
  - [ ] Create error pattern analysis
  - [ ] Build usage statistics reporting

- [ ] **Task 5 (AC: 5):** Create operational tools
  - [ ] Implement health check endpoints
  - [ ] Add metrics export functionality
  - [ ] Create debug endpoints
  - [ ] Add performance profiling tools

- [ ] **Task 6 (AC: 1-5):** Testing and validation
  - [ ] Test monitoring accuracy
  - [ ] Validate alerting system
  - [ ] Test health dashboard functionality
  - [ ] Verify operational tools

---

## Dev Notes

### ⚠️ **CRITICAL IMPLEMENTATION NOTE**
**Monitoring is split between n8n and backend!**

**Implementation Approach:**
- ✅ **Backend monitoring** - Database metrics, API performance, system health
- ✅ **n8n monitoring** - Workflow execution, Ollama health, AI processing metrics
- ✅ **Integration** - Backend calls n8n health endpoints for comprehensive status
- ❌ **DO NOT duplicate monitoring logic**

**n8n Monitoring:**
- Use n8n built-in monitoring for workflows
- Create health check workflows for Ollama
- Export metrics via webhook endpoints
- Backend aggregates all monitoring data

### Previous Story Insights
**From Story 1.1:**
- Ollama service is accessible at `http://vpn.zopost.vn:11434`
- AI Service module structure is in place
- Database models (AIIntent, AIResponse) are created
- Basic API endpoints are implemented

**From Story 1.2:**
- Intent analysis with confidence scoring is implemented via n8n
- Entity extraction system is working via n8n workflows
- 5-10 intent types are defined and configured
- Confidence thresholds are established

**From Story 1.3:**
- Fallback mechanisms are implemented via n8n
- Error handling is comprehensive via n8n workflows
- Health monitoring framework is in place
- Fallback logging is operational

**Key Learnings to Apply:**
- Use established health monitoring framework
- Leverage existing logging infrastructure
- Maintain database model relationships
- Follow established API patterns

### Data Models
**New Monitoring Models:**
```prisma
model AIMetrics {
  id          String   @id @default(uuid())
  timestamp   DateTime @default(now())
  metricType  String   // "response_time", "throughput", "error_rate"
  metricValue Float
  component   String   // "ollama", "fallback", "database"
  context     Json?    // Additional context data
  
  @@index([timestamp])
  @@index([metricType])
  @@index([component])
}

model ServiceAlert {
  id          String   @id @default(uuid())
  timestamp   DateTime @default(now())
  alertType   String   // "critical", "warning", "info"
  component   String   // "ollama", "fallback", "database"
  message     String
  status      String   @default("active") // "active", "acknowledged", "resolved"
  acknowledgedBy String?
  acknowledgedAt DateTime?
  resolvedAt  DateTime?
  context     Json?
  
  @@index([timestamp])
  @@index([alertType])
  @@index([status])
  @@index([component])
}

model HealthCheck {
  id          String   @id @default(uuid())
  timestamp   DateTime @default(now())
  component   String   // "ollama", "fallback", "database", "overall"
  status      String   // "healthy", "degraded", "unhealthy"
  responseTime Int?    // milliseconds
  details     Json?    // Component-specific health details
  
  @@index([timestamp])
  @@index([component])
  @@index([status])
}
```

[Source: docs/backend-architecture.md#monitoring-architecture]

### API Specifications
**Enhanced GET /api/ai/health:**
- **Purpose:** Comprehensive health check with detailed metrics
- **Authentication:** None required
- **Response:** 
  ```json
  {
    "status": "string", // "healthy", "degraded", "unhealthy"
    "timestamp": "ISO datetime",
    "overall": {
      "status": "string",
      "responseTime": "number (ms)",
      "lastCheck": "ISO datetime"
    },
    "components": {
      "ollama": {
        "status": "string",
        "responseTime": "number (ms)",
        "model": "string",
        "lastCheck": "ISO datetime"
      },
      "fallback": {
        "status": "string",
        "availability": "boolean",
        "lastUsed": "ISO datetime",
        "usageCount": "number"
      },
      "database": {
        "status": "string",
        "responseTime": "number (ms)",
        "connections": "number",
        "lastCheck": "ISO datetime"
      }
    },
    "performance": {
      "averageResponseTime": "number (ms)",
      "requestsPerMinute": "number",
      "errorRate": "float",
      "throughput": "number"
    }
  }
  ```

**New GET /api/ai/metrics:**
- **Purpose:** Get performance metrics and trends
- **Authentication:** Bearer token required
- **Query Parameters:**
  - `timeframe`: "1h", "6h", "24h", "7d", "30d"
  - `metricType`: "response_time", "throughput", "error_rate"
  - `component`: "ollama", "fallback", "database", "overall"
- **Response:** 
  ```json
  {
    "timeframe": "string",
    "metrics": [
      {
        "timestamp": "ISO datetime",
        "metricType": "string",
        "metricValue": "float",
        "component": "string"
      }
    ],
    "summary": {
      "min": "float",
      "max": "float",
      "average": "float",
      "trend": "string" // "improving", "stable", "degrading"
    }
  }
  ```

**New GET /api/ai/alerts:**
- **Purpose:** Get active and recent alerts
- **Authentication:** Bearer token required
- **Query Parameters:**
  - `status`: "active", "acknowledged", "resolved"
  - `alertType`: "critical", "warning", "info"
  - `component`: "ollama", "fallback", "database"
- **Response:** 
  ```json
  {
    "alerts": [
      {
        "id": "string",
        "timestamp": "ISO datetime",
        "alertType": "string",
        "component": "string",
        "message": "string",
        "status": "string",
        "acknowledgedBy": "string?",
        "acknowledgedAt": "ISO datetime?"
      }
    ],
    "summary": {
      "total": "number",
      "active": "number",
      "acknowledged": "number",
      "resolved": "number"
    }
  }
  ```

**New POST /api/ai/alerts/{id}/acknowledge:**
- **Purpose:** Acknowledge an alert
- **Authentication:** Bearer token required
- **Response:** 
  ```json
  {
    "id": "string",
    "status": "acknowledged",
    "acknowledgedBy": "string",
    "acknowledgedAt": "ISO datetime"
  }
  ```

[Source: docs/backend-architecture.md#rest-api-spec]

### Component Specifications
**Metrics Collection Service (`src/services/metrics-collector.service.js`):**
- **Class:** `MetricsCollectorService`
- **Methods:**
  - `recordMetric(metricType, metricValue, component, context)` - Record a metric
  - `getMetrics(timeframe, metricType, component)` - Get metrics for analysis
  - `calculateTrends(metrics)` - Calculate performance trends
  - `exportMetrics(format, timeframe)` - Export metrics for external systems
- **Dependencies:** Prisma client, Winston logger, time utilities

**Health Monitoring Service (`src/services/health-monitor.service.js`):**
- **Class:** `HealthMonitorService`
- **Methods:**
  - `checkComponentHealth(component)` - Check health of specific component
  - `getOverallHealth()` - Get overall system health
  - `runHealthChecks()` - Run all health checks
  - `getHealthHistory(component, timeframe)` - Get health check history
- **Dependencies:** Component health checkers, metrics collector

**Alert Management Service (`src/services/alert-manager.service.js`):**
- **Class:** `AlertManagerService`
- **Methods:**
  - `createAlert(alertType, component, message, context)` - Create new alert
  - `acknowledgeAlert(alertId, userId)` - Acknowledge an alert
  - `resolveAlert(alertId, resolution)` - Resolve an alert
  - `getActiveAlerts(filters)` - Get active alerts
  - `checkAlertThresholds(metrics)` - Check if alerts should be triggered
- **Dependencies:** Prisma client, notification service, metrics collector

**Notification Service (`src/services/notification.service.js`):**
- **Class:** `NotificationService`
- **Methods:**
  - `sendAlert(alert, channels)` - Send alert notifications
  - `sendEscalation(alert, escalationLevel)` - Send escalation notifications
  - `configureChannels(channels)` - Configure notification channels
  - `getNotificationHistory(alertId)` - Get notification history
- **Dependencies:** Email service, Slack service, configuration

**Performance Profiler Service (`src/services/performance-profiler.service.js`):**
- **Class:** `PerformanceProfilerService`
- **Methods:**
  - `startProfiling(operationId)` - Start performance profiling
  - `endProfiling(operationId, result)` - End performance profiling
  - `getProfilingData(operationId)` - Get profiling data
  - `analyzePerformance(operationType, timeframe)` - Analyze performance patterns
- **Dependencies:** Metrics collector, Winston logger

[Source: docs/backend-architecture.md#components]

### File Locations
**New Files to Create:**
- `src/services/metrics-collector.service.js` - Metrics collection service
- `src/services/health-monitor.service.js` - Enhanced health monitoring
- `src/services/alert-manager.service.js` - Alert management service
- `src/services/notification.service.js` - Notification service
- `src/services/performance-profiler.service.js` - Performance profiling
- `src/controllers/monitoring.controller.js` - Monitoring API controller
- `src/middleware/metrics-collector.js` - Metrics collection middleware
- `src/config/monitoring.js` - Monitoring configuration
- `src/utils/health-checkers.js` - Component health checkers

**Files to Modify:**
- `src/controllers/ai.controller.js` - Enhance health endpoints
- `src/app.js` - Add monitoring routes and middleware
- `prisma/schema.prisma` - Add monitoring models
- `src/services/ai.service.js` - Add performance profiling

[Source: docs/backend-architecture.md#source-tree]

### Testing Requirements
**Unit Tests:**
- Test metrics collection accuracy
- Test health check functionality
- Test alert creation and management
- Test notification delivery
- Test performance profiling

**Integration Tests:**
- Test complete monitoring pipeline
- Test alert threshold triggering
- Test health dashboard functionality
- Test metrics export and analysis

**Test Coverage Target:** >85% for new monitoring code

**Test Scenarios:**
- Service degradation scenarios
- Alert threshold testing
- Performance under load
- Notification delivery
- Metrics accuracy validation

[Source: docs/backend-architecture.md#test-strategy]

### Technical Constraints
**Performance Monitoring:**
- **Metrics Collection:** Every request and operation
- **Data Retention:** 30 days for detailed metrics, 1 year for aggregated data
- **Update Frequency:** Real-time for health checks, 1-minute for metrics
- **Storage:** Efficient time-series data storage

**Alerting System:**
- **Thresholds:** Configurable per metric and component
- **Notification Channels:** Email, Slack, webhook
- **Escalation:** Automatic escalation after configurable delays
- **Acknowledgment:** Required for critical alerts

**Health Checks:**
- **Frequency:** Every 30 seconds for critical components
- **Timeout:** 10 seconds per health check
- **Dependencies:** Minimal external dependencies
- **Recovery:** Automatic recovery detection

[Source: docs/ai-intent-analysis-strategy.md#monitoring-requirements]

---

## Testing

### Test Cases

**Unit Tests:**
- [ ] Metrics collection records accurate data
- [ ] Health checks report correct status
- [ ] Alert system triggers at correct thresholds
- [ ] Notification service delivers alerts
- [ ] Performance profiling captures timing data
- [ ] Data export formats correctly

**Integration Tests:**
- [ ] Complete monitoring pipeline works end-to-end
- [ ] Health dashboard displays accurate information
- [ ] Alert system responds to service issues
- [ ] Metrics analysis provides useful insights
- [ ] Performance profiling helps optimization

**Manual Tests:**
- [ ] Health dashboard displays real-time status
- [ ] Alerts are triggered for service issues
- [ ] Notifications are delivered to configured channels
- [ ] Metrics export works for external systems
- [ ] Performance profiling helps identify bottlenecks

---

## Dev Agent Record

### Completion Notes
*To be filled by Dev Agent during implementation*

### Debug Log
*To be filled by Dev Agent during implementation*

### Change Log
*To be filled by Dev Agent during implementation*

---

## QA Results
*To be filled by QA Agent during review*

---

## Project Structure Notes

**Alignment Status:** ✅ **FULLY ALIGNED**

**Project Structure Verification:**
- ✅ Monitoring services follow `src/services/` pattern
- ✅ Monitoring controller follows `src/controllers/` pattern
- ✅ Monitoring middleware follows `src/middleware/` pattern
- ✅ Configuration files follow `src/config/` pattern
- ✅ Utility files follow `src/utils/` pattern
- ✅ API endpoints follow existing REST pattern
- ✅ Database models follow existing Prisma pattern

**No structural conflicts identified.** Story implementation follows established project patterns exactly.

---

## Dependencies

**Internal Dependencies:**
- Story 1.1 must be completed (Ollama service, AI models, basic API)
- Story 1.2 must be completed (Intent analysis, confidence scoring)
- Story 1.3 must be completed (Fallback mechanisms, error handling)
- Existing Express app structure
- Existing Prisma database setup
- Existing authentication middleware

**External Dependencies:**
- Monitoring and alerting libraries
- Notification service integrations
- Time-series data processing utilities

**Dependency Status:** ✅ **READY** - All internal dependencies from Stories 1.1, 1.2, and 1.3 are satisfied.

---

## Risk Assessment

**Risk Level:** LOW

**Potential Risks:**
1. **Performance impact of monitoring** - Mitigation: Efficient metrics collection
2. **Alert fatigue** - Mitigation: Configurable thresholds and escalation
3. **Data storage growth** - Mitigation: Data retention policies and aggregation

**Risk Mitigation Status:** ✅ **ADDRESSED**

---

## Definition of Done

- [ ] Performance monitoring system is operational
- [ ] Health dashboard displays accurate real-time information
- [ ] Alerting system triggers for service issues
- [ ] Notification system delivers alerts to configured channels
- [ ] Comprehensive logging captures all required information
- [ ] Operational tools are functional and tested
- [ ] Metrics export works for external monitoring systems
- [ ] Unit tests passing with >85% coverage
- [ ] Integration tests passing
- [ ] Performance testing completed
- [ ] Documentation updated
- [ ] Code reviewed and approved

---

*Story created using BMAD-METHOD™ framework*
